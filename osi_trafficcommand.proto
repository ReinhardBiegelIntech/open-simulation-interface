syntax = "proto2";

option optimize_for = SPEED;

import "osi_version.proto";
import "osi_common.proto";
import "osi_trajectorycommand.proto";

package osi3;

//
// \brief The TrafficCommand
//
//
message TrafficCommand
{
    // The interface version used by the sender (i.e. the simulation
    // environment).
    //
    optional InterfaceVersion version = 1;

    // The status of the command.
    //
    // \note The agent should set the status, as he knows the status?
    // Dbecker: How would that work? TrafficCommand is only an input
    //
    //enum ExecutionStatus {
    //  IDLE = 1;
    //  RUNNING = 2;
    //  SUCCESS = 3;
    //  FAILURE = 4;
    //}
    //optional ExecutionStatus execution_status = 2 [default = IDLE];

    // "event" flag that a new command is present
    //
    // \note this flag is checked by the agent in every time stamp.
    //       if true, the trajectory will be extracted from the command
    //       if false, the TrafficCommand message will be ignored.
    optional bool receive_new_command = 2;

    // The start_time could be used to set a starttime of exectution
    //
    // \note Should be definitely optional?
    //
    // \note What should be the desirec behaviour if starttime is already exceeded?
    // One idea: The agent should wait until the starttime to execute.
    // If time is already ahead, it can start directly
    //
    // \note Zero time point does not need to coincide with the UNIX epoch.
    //

    // Dbecker: Time is included in trajectory for now
    //optional Timestamp start_time = 3;

    // The end_time could be used to set a endtime
    //
    // \note Should be definitely optional?
    //
    // \note This one is tricky and I am not sure about this. It could eiter determine
    // the timeframe in which a traffic command needs to be finished before, or it could determine
    // the endtime, which indicates how long a command should go on.
    // THis would definitly require a good documentation ...
    //
    // \note Zero time point does not need to coincide with the UNIX epoch.
    //

    // Dbecker: Time is included in trajectory for now
    //optional Timestamp end_time = 4;

    // The type of command which should be used? Could avoid checking all possible
    // commands?
    //
    // \note This should be set?
    //
    // \note If NULL, none command is send?
    //
    // \note Extend list?
    //
    // Dbecker: placeholder for later...
    enum CommandType {
      TARGET_COMMAND = 1;
      MANEUVER_COMMAND = 2;
      TRAJECTORY_COMMAND = 3;
      PEDALERY_COMMAND = 4;
      CONTROLLER_COMMAND = 5;
    }
    optional CommandType command_type = 5 [default = TRAJECTORY_COMMAND];

    repeated TrajectoryCommand trajectory_command = 6;

}
