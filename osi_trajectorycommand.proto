syntax = "proto2";

option optimize_for = SPEED;

import "osi_version.proto";
import "osi_common.proto";

package osi3;


//
// \brief The TrajectoryCommand
//
// I have at least three types of trajectories in my mind:
//    1. A trajectory demand (Vorgabe) with (only?) xyz points.
//       Agent should TRY to follow that.
//    2. A fixed trajectory (xyz/rpy) which is manditory to follow.
//       An Agent needs to follow that, but could vary speed?
//    3. A fully defined & fixed trajectory (xyz/rph and derivates) with time stamps
//       An Agent needs to follow that exactly
//
// Dbecker: for MS1 there is will be a trajectory of the form (time,x,y) in global coordinates

message TrajectoryCommand
{
    // The interface version used by the sender (i.e. the simulation
    // environment).
    //
    //  Should that be again in here?
    //
    optional InterfaceVersion version = 1;

    // The status of the command.
    //
    // \note The agent should set the status, as he knows the status?
    //
    // Dbecker: How would that work? TrafficCommand is only an input
    //enum ExecutionStatus {
    //  IDLE = 0;
    //  RUNNING = 1;
    //  SUCCESS = 2;
    //  FAILURE = 3;
    //}
    //optional ExecutionStatus execution_status = 2 [default = IDLE];

    // The start_time could be used to set a starttime of exectution
    //
    // \note Should be definitely optional?
    //
    // \note What should be the desirec behaviour if starttime is already exceeded?
    // One idea: The agent should wait until the starttime to execute.
    // If time is already ahead, it can start directly
    //
    // \note Zero time point does not need to coincide with the UNIX epoch.
    //
    // dbecker: leave empty for MS1
    optional Timestamp start_time = 3;

    // The end_time could be used to set a endtime
    //
    // \note Should be definitely optional?
    //
    // \note This one is tricky and I am not sure about this. It could eiter determine
    // the timeframe in which a traffic command needs to be finished before, or it could determine
    // the endtime, which indicates how long a command should go on.
    // THis would definitly require a good documentation ...
    //
    // \note Zero time point does not need to coincide with the UNIX epoch.
    //
    // dbecker: leave empty for MS1
    optional Timestamp end_time = 4;


    // The type of command which should be used? Could avoid checking all
    // commands?
    //
    // \note This should be set?
    //
    // \note If NULL, none command is send?
    //
    // \note Extend list?
    //
    enum CommandType {
      TRAJECTORYDEMAND = 0;
      TRAJECTORYFIX = 1;
      TRAJECTORYFIXWITHTIME = 2;
    }
    optional CommandType command_type = 5 [default = TRAJECTORYFIXWITHTIME];

    // A list of TrajectoryPoints (?)
    //
    // \note OSI uses singular instead of plural for repeated field names.
    //
    repeated TrajectoryPoint trajectory_point = 6;

}


//
// \brief The trajectory point definition
//
// A trajectory point contains a BaseMoving (full state with xyz/rph and the derivates:
// linear /angular velocity and acceleration.
//
// Furthermore it could contain a time stamp
//
message TrajectoryPoint
{
    // The timestamp of a trajectory point
    //
    // \note Should be definitely optional?
    //
    // \note Zero time point does not need to coincide with the UNIX epoch.
    //
    optional Timestamp time_stamp = 0;


    // A list of BaseMovings (?)
    //
    // \note OSI uses singular instead of plural for repeated field names.
    //
    // dbecker: for MS1 only global x,y coordinates need to be filled here.
    //          heading can be optional, will be calculated inside the model if desired
    //          e.g. heading could be always in direction of the current tangent to the trajectory
    //          e.g. pedestrian could be provided with additional heading
    optional BaseMoving base_moving = 1;
}
